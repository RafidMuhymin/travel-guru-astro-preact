<script>
  ((w, d) => {
    navigator.connection.saveData ||
      requestIdleCallback(
        () => {
          w.observedHrefs || (w.observedHrefs = []);
          w.fetchedHrefs || (w.fetchedHrefs = []);
          w.timeoutIDArray = [];

          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry, i) => {
                entry.isIntersecting
                  ? (timeoutIDArray[i] = setTimeout(() => {
                      prefetch(entry.target.href);
                    }, 500))
                  : clearTimeout(timeoutIDArray[i]);
              });
            },
            { threshold: 0.25 }
          );

          w.fetchHTML = (href) => {
            if (fetchedHrefs.includes(href)) {
              return;
            }
            fetchedHrefs.push(href);
            fetch(href);
          };

          document
            .querySelectorAll('a:not([download])[href^="/"')
            .forEach((anchor) => {
              anchor.addEventListener("click", (e) => {
                if (!w.event.ctrlKey) {
                  e.preventDefault();
                  navigate(anchor.href);
                }
              });

              if (observedHrefs.includes(anchor.href)) {
                return;
              }
              observedHrefs.push(anchor.href);
              observer.observe(anchor);
              anchor.addEventListener("mouseover", fetchHTML(anchor.href));
              anchor.addEventListener("touchstart", fetchHTML(anchor.href));
            });

          w.navigate = (href) => {
            if (location.href !== href && location.pathname !== href) {
              fetch(href)
                .then((res) => res.text())
                .then((html) => {
                  const doc = new DOMParser().parseFromString(
                    html,
                    "text/html"
                  );
                  d.documentElement.replaceWith(doc.documentElement);
                  for (const script of d.scripts) {
                    eval(script.innerHTML);
                  }
                  history.pushState({}, d.title, href);
                });
            }
          };

          w.prefetch = (href) => {
            if (!d.querySelector('link[href="' + href + '"]')) {
              const link = d.createElement("link");
              link.href = href;
              link.rel = "prefetch";
              d.head.appendChild(link);
            }
          };
        },
        { timeout: 2000 }
      );
  })(this, this.document);
</script>